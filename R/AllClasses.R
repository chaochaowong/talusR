#' @rdname TalusDataSet
#' @exportClass TalusDataSet
#'
# 1) Define class
setClass(
  "TalusDataSet", # your new class name
  contains = "SummarizedExperiment" # inherit all the SE machinery
)

# 2) validity
setValidity("TalusDataSet", function(object) {
  if (!("abundance" %in% assayNames(object))) {
    return("the assays slot must contain a matrix named 'abound'")
  }

  ig <- metadata(object)$intensity_group
  # require exactly one value, and it must be "protein" or "peptide"
  if (length(ig) != 1 || !ig %in% c("protein", "peptide")) {
    return("`intensity_group` must be a single string: either 'protein' or 'peptide'")
  }

  TRUE
})

#' TalusDataSet object and constructor
#'
#' \code{TalusDataSet} is a subclass of \code{SummerizedExperiment} used
#' to store the input mass-spectrum intensity signals, which reflects the
#' protein abundance, and addition annotation of intensity group
#' (either protein or peptide) and input format (DIA-NN).
#' The constructor functions create a \code{TalusDataSet} instance
#' from a matrix, abundance files generated by metrics from DIA-NN,
#' and meta corresponding to the protein (peptide) annotation and
#' sample (run) annotation.
#'
#' @param assay_data a matrix input: a matrix of non-negative integers of MS signal levels
#' @param col_data for matrix input: a \code{DataFrame} or \code{data.frame} with at least a single column. Rows of \code{col_data} correspond to columns of \code{assay_data}.
#' @param row_data for matrix input: a \code{DataFrame} or \code{data.frame} with at least a single column. Rows of \code{row_data} correspond to the rows of \code{assay_data}.
#' @param intensity_group a character string specifying the levels of abundance, either protein or peptide.
#' @param matric  a character string specifying the metric that generates the mass-spectrum signal values.
#' @param log_transform a character string of the log transformation method.
#'
#' @return a \code{TalusDataSet} object.
#' @export
#' @author Chao-Jen Wong
#' @rdname TalusDataSet
#' @docType class
#' @aliases TalusDataSet TalusDataSet-class
TalusDataSet <- function(assay_data, col_data, row_data,
                         intensity_group = 'protein',
                         metric = 'DIA-NN',
                         log_transform = 'log2') {
  # check that these agree in number
  stopifnot(ncol(assay_data) == nrow(col_data))
  stopifnot(nrow(assay_data) == nrow(row_data))

  # we expect a matrix of counts, which are non-negative integers
  assay_data <- as.matrix(assay_data)

  if (is(col_data, "data.frame")) {
    col_data <- as(col_data, "DataFrame")
  }

  if (is(row_data, "data.frame")) {
    row_data <- as(row_data, "DataFrame")
  }

  # check if the rownames of colData are simply in different order
  # than the colnames of the countData, if so throw an error
  # as the user probably should investigate what's wrong
  if (!is.null(rownames(col_data)) & !is.null(colnames(assay_data))) {
    if (all(sort(rownames(col_data)) == sort(colnames(assay_data)))) {
      if (!all(rownames(col_data) == colnames(assay_data))) {
        stop(paste("rownames of the col_data:
  ", paste(rownames(col_data), collapse = ","), "
  are not in the same order as the colnames of the countData:
  ", paste(colnames(assay_data), collapse = ",")))
      }
    }
  }

  if (is.null(rownames(col_data)) & !is.null(colnames(assay_data))) {
    rownames(col_data) <- colnames(assay_data)
  }

  se <- SummarizedExperiment(
    assays  = SimpleList(abundance = assay_data),
    colData = col_data,
    rowData = row_data
  )

  metadata(se)$intensity_group <- intensity_group
  metadata(se)$metric          <- metric
  metadata(se)$log_transform   <- 'log2'

  tds <- new("TalusDataSet", se)

}

#' TalusDataSetList-class and constructor
#'
#' A \code{TalusDataSetList} is an S4 \code{\linkS4class{SimpleList}} containing
#' one or more \code{\linkS4class{TalusDataSet}} objects.
#'
#' @name TalusDataSetList-class
#' @aliases TalusDataSetList-class TalusDataSetList
#' @docType class
#' @importFrom S4Vectors SimpleList
#' @exportClass TalusDataSetList
#' @author Chao-Jen Wong
setClass(
  "TalusDataSetList",
  contains  = "SimpleList",
  prototype = prototype(elementType = "TalusDataSet")
)

## 2. A validity method to be extraâ€sure:

setValidity("TalusDataSetList", function(object) {
  ok <- vapply(object, is, logical(1), "TalusDataSet")
  if (!all(ok))
    return("All elements must be TalusDataSet objects")
  TRUE
})

## 3. A contstructor

#' @rdname TalusDataSetList-class
#' @param lst list of TalusDataSet objects
#' @return a validated TalusDataSetList
#' @export
TalusDataSetList <- function(lst) {
  # Wrap a base list in a SimpleList, then coerce
  new("TalusDataSetList", listData = lst)
}

